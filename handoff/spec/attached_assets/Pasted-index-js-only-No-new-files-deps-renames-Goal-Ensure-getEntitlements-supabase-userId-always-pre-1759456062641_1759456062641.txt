index.js only. No new files/deps/renames.

Goal

Ensure getEntitlements(supabase, userId) always prefers the active Stripe subscription:

If is_subscribed = true or stripe_subscription_status ∈ { 'active','trialing' } AND subscription_tier ∈ { 'pro','casual' } → use subscription_tier.

Else → fall back to plan_tier (the dev/legacy field).

Add a debug view: ?debug=1 (or &_debug=1) on both entitlements routes to include _meta with the raw profile fields and the chosen source. (No contract change unless debug flag is present.)

Implement (surgical edits in index.js)

Replace getEntitlements with this version (keep name/signature; callers unchanged):

const TIER_RULES = {
  free:   { quota: 2,  preview: false },
  casual: { quota: 5,  preview: true  },
  pro:    { quota: 25, preview: true  },
};

async function getEntitlements(supabase, userId, opts = {}) {
  const debug = !!(opts.debug);

  // Read profile including subscription fields
  let { data: prof, error: profErr } = await supabase
    .from('profiles')
    .select('plan_tier, subscription_tier, stripe_subscription_status, is_subscribed')
    .eq('user_id', userId)
    .maybeSingle();

  // Auto-create if missing
  if (!prof && profErr && profErr.code === 'PGRST116') {
    const { data: newProf } = await supabase
      .from('profiles')
      .insert({ user_id: userId, plan_tier: 'free' })
      .select('plan_tier, subscription_tier, stripe_subscription_status, is_subscribed')
      .maybeSingle();
    prof = newProf;
    profErr = null;
  }

  if (profErr) {
    const payload = { tier: 'free', quota: 2, previewAllowed: false, remaining: 0, error: String(profErr.message || profErr) };
    return debug ? { ...payload, _meta: { source:'error', prof:null } } : payload;
  }

  const norm = v => (v ?? '').toString().trim().toLowerCase();
  const planTier = norm(prof?.plan_tier || 'free');
  const subTier  = norm(prof?.subscription_tier);
  const subStat  = norm(prof?.stripe_subscription_status);
  const isSub    = !!prof?.is_subscribed;

  const subscriptionActive = isSub || subStat === 'active' || subStat === 'trialing';
  const useSubTier = subscriptionActive && (subTier === 'pro' || subTier === 'casual');

  let tier = useSubTier ? subTier : planTier;
  if (!TIER_RULES[tier]) tier = 'free';

  // Count user's projects
  const { count } = await supabase
    .from('projects')
    .select('id', { count: 'exact', head: true })
    .eq('user_id', userId);
  const used = count || 0;
  const rules = TIER_RULES[tier];
  const remaining = Math.max(0, rules.quota - used);

  const payload = {
    tier,
    quota: rules.quota,
    previewAllowed: !!rules.preview,
    remaining,
  };

  return debug
    ? { ...payload, _meta: { source: useSubTier ? 'subscription_tier' : 'plan_tier', planTier, subTier, subStat, isSub, used } }
    : payload;
}


Wire debug flag in endpoints
In both routes:

GET /me/entitlements/:userId

GET /me/entitlements (query alias with user_id)

Parse const debug = req.query.debug === '1' || req.query._debug === '1'; and call:

const ent = await getEntitlements(supabase, userId, { debug });
return res.json({ ok: true, ...ent });


Do not change anything else about these routes.

Acceptance

GET /me/entitlements?user_id=e4cb3591-7272-46dd-b1f6-d7cc4e2f3d24&debug=1 returns:

tier: 'pro', quota: 25, previewAllowed: true, and

_meta.source: 'subscription_tier' with _meta.subTier: 'pro', _meta.subStat: 'active', _meta.isSub: true.

If subscription is canceled (not active/trialing and is_subscribed is false), tier falls back to plan_tier.

No regressions to /api/projects/*.